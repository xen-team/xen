#include "texture.hpp"
#include <GL/glext.h>

#include <render/render.hpp>

namespace xen {
Texture::Texture(TextureSettings& settings) : settings(settings) {}

// TODO: Current Texture Copy implementation only copies the highest resolution mip (level 0)
// This implementation is fine when the hardware generates the mips because our newly created texture will do the same
// This only fails if the mip levels contain custom data that was generated by the hardware via glGenerateMipmap(...)
Texture::Texture(Texture const& texture) :
    texture_target(texture.texture_target), extent(texture.extent), settings(texture.settings)
{
    GL_CALL(glGenTextures(1, &id));
    bind();

    GL_CALL(glTexImage2D(
        texture_target, 0, settings.texture_format, extent.x, extent.y, 0, GL_RGB, GL_UNSIGNED_BYTE, nullptr
    ));

    apply_texture_settings();

    GL_CALL(glCopyImageSubData(
        texture.get_id(), texture.get_texture_target(), 0, 0, 0, 0, id, texture_target, 0, 0, 0, 0, extent.x, extent.y,
        1
    ));

    unbind();

    Log::debug(
        "Render::Texture "
        "created texture with id: ",
        id
    );
}

Texture::~Texture()
{
    GL_CALL(glDeleteTextures(1, &id));
    Log::debug(
        "Render::Texture "
        " deleted texture with id: ",
        id
    );
    id = 0;
}

void Texture::apply_texture_settings()
{
    // Texture wrapping
    GL_CALL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, settings.texture_wrap_s_mode));
    GL_CALL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, settings.texture_wrap_t_mode));
    if (settings.has_border) {
        GL_CALL(glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, &settings.border_color[0]));
    }

    // Texture filtering
    GL_CALL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, settings.texture_minification_filter_mode));
    GL_CALL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, settings.texture_magnification_filter_mode));

    // Mipmapping
    if (settings.has_mips) {
        GL_CALL(glGenerateMipmap(GL_TEXTURE_2D));
        GL_CALL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_LOD_BIAS, settings.mip_bias));
    }

    // Anisotropic filtering (Check with renderer to see the max amount allowed
    float anistropy_amount =
        std::min(settings.texture_anisotropy_level, Render::get()->get_renderer()->get_renderer_data().max_anisotropy);

    GL_CALL(glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anistropy_amount));
}

void Texture::generate_2d_texture(
    Vector2ui const& extent, GLenum const data_format, GLenum const pixel_data_type, void const* data
)
{
    texture_target = GL_TEXTURE_2D;
    this->extent = extent;

    // If GL_NONE is specified, set the texture format to the data format
    if (settings.texture_format == GL_NONE) {
        settings.texture_format = data_format;
    }
    // Check if the texture is SRGB, if so change the texture format
    if (settings.is_srgb) {
        switch (data_format) {
        case GL_RGB:
            settings.texture_format = GL_SRGB;
            break;
        case GL_RGBA:
            settings.texture_format = GL_SRGB_ALPHA;
            break;
        default:
            Log::warning("Render::Texture "
                         "generate_2d_texture() incorrect texture format type");

            settings.texture_format = GL_SRGB;
            break;
        }
    }

    GL_CALL(glGenTextures(1, &id));

    bind();

    GL_CALL(glTexImage2D(
        GL_TEXTURE_2D, 0, settings.texture_format, extent.x, extent.y, 0, data_format, pixel_data_type, data
    ));

    apply_texture_settings();

    unbind();
}

void Texture::generate_2d_multisample_texture(Vector2ui const& extent)
{
    // Multisampled textures do not support mips or filtering/wrapping options
    texture_target = GL_TEXTURE_2D_MULTISAMPLE;
    this->extent = extent;

    GL_CALL(glGenTextures(1, &id));

    bind();

    GL_CALL(glTexImage2DMultisample(
        GL_TEXTURE_2D_MULTISAMPLE, msaa_sample_amount, settings.texture_format, extent.x, extent.y, GL_TRUE
    ));

    unbind();
}

void Texture::generate_mips()
{
    settings.has_mips = true;
    if (is_generated()) {
        bind();

        GL_CALL(glGenerateMipmap(texture_target));
    }
}

void Texture::bind(int const unit) const
{
    GL_CALL(glActiveTexture(GL_TEXTURE0 + unit));
    GL_CALL(glBindTexture(texture_target, id));
}

void Texture::unbind() const
{
    GL_CALL(glBindTexture(texture_target, 0));
}

void Texture::set_texture_wrap_s(GLenum const texture_wrap_mode)
{
    if (settings.texture_wrap_s_mode == texture_wrap_mode) {
        return;
    }

    settings.texture_wrap_s_mode = texture_wrap_mode;
    if (is_generated()) {
        GL_CALL(glTexParameteri(texture_target, GL_TEXTURE_WRAP_S, settings.texture_wrap_s_mode));
    }
}

void Texture::set_texture_wrap_t(GLenum const texture_wrap_mode)
{
    if (settings.texture_wrap_t_mode == texture_wrap_mode) {
        return;
    }

    settings.texture_wrap_t_mode = texture_wrap_mode;
    if (is_generated()) {
        GL_CALL(glTexParameteri(texture_target, GL_TEXTURE_WRAP_T, settings.texture_wrap_t_mode));
    }
}

void Texture::set_has_border(bool const has_border)
{
    if (settings.has_border == has_border) {
        return;
    }

    settings.has_border = has_border;
    if (is_generated()) {
        GL_CALL(glTexParameterfv(texture_target, GL_TEXTURE_BORDER_COLOR, &settings.border_color[0]));
    }
}

void Texture::set_border_color(Vector4f const& border_color)
{
    if (settings.border_color == border_color || !settings.has_border) {
        return;
    }

    settings.border_color = border_color;
    if (is_generated()) {
        GL_CALL(glTexParameterfv(texture_target, GL_TEXTURE_BORDER_COLOR, &settings.border_color[0]));
    }
}

void Texture::set_texture_min_filter(GLenum const texture_filter_mode)
{
    if (settings.texture_minification_filter_mode == texture_filter_mode) {
        return;
    }

    settings.texture_minification_filter_mode = texture_filter_mode;
    if (is_generated()) {
        GL_CALL(glTexParameteri(texture_target, GL_TEXTURE_MIN_FILTER, settings.texture_minification_filter_mode));
    }
}

void Texture::set_texture_mag_filter(GLenum const texture_filter_mode)
{
    assert(texture_filter_mode <= GL_LINEAR);

    /*"Texture's magnification filter exceeded bilinear filtering which won't result "
        "in any visual improvements and will just cost more"*/

    if (settings.texture_magnification_filter_mode == texture_filter_mode) {
        return;
    }

    settings.texture_magnification_filter_mode = texture_filter_mode;
    if (is_generated()) {
        GL_CALL(glTexParameteri(texture_target, GL_TEXTURE_MAG_FILTER, settings.texture_magnification_filter_mode));
    }
}

void Texture::set_anisotropic_filtering_mode(float const texture_anisotropy_level)
{
    if (settings.texture_anisotropy_level == texture_anisotropy_level) {
        return;
    }

    settings.texture_anisotropy_level = texture_anisotropy_level;
    if (is_generated()) {
        float max_anisotropy;
        GL_CALL(glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &max_anisotropy));

        float anistropy_amount = std::min(max_anisotropy, settings.texture_anisotropy_level);
        GL_CALL(glTexParameterf(texture_target, GL_TEXTURE_MAX_ANISOTROPY_EXT, anistropy_amount));
    }
}

void Texture::set_mip_bias(int const mip_bias)
{
    if (settings.mip_bias == mip_bias) {
        return;
    }

    settings.mip_bias = mip_bias;
    if (is_generated()) {
        GL_CALL(glTexParameteri(texture_target, GL_TEXTURE_LOD_BIAS, settings.mip_bias));
    }
}

void Texture::set_has_mips(bool const has_mips)
{
    if (settings.has_mips == has_mips) {
        return;
    }

    settings.has_mips = has_mips;
    if (is_generated() && has_mips) {
        GL_CALL(glGenerateMipmap(texture_target));
    }
}
}